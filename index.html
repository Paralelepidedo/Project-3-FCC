<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="styles.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manual de Python</title>
</head>
<body>
    <nav id="navbar">
        <header>Manual de Python</header>
        <ul>
            <li><a class="nav-link" href="#Introducción_a_Python">Introducción a Python</a></li>
                <ul class="sub-menu">
                    <li><a class="nav-link" href="#Qué_es_Python">Qué es Python</a></li>
                    <li><a class="nav-link" href="#Principales_ventajas_de_Python">Principales ventajas de Python</a></li>
                    <li><a class="nav-link" href="#Tipos_de_ejecución">Tipos de ejecución</a></li>
                </ul>
            <li><a class="nav-link" href="#Hello_world">Hello world</a></li>
            <li><a class="nav-link" href="#Tipos_de_datos_simples">Tipos de datos simples</a></li>
                <ul class="sub-menu">
                    <li><a class="nav-link" href="#Tipos_de_datos_primitivos_simples">Tipos de datos primitivos simples</a></li>
                    <li><a class="nav-link" href="#Tipos_de_datos_primitivos_compuestos_contenedores">Tipos de datos primitivos compuestos contenedores</a></li>
                    <li><a class="nav-link" href="#Clase_de_un_dato_type">Clase de un dato type</a></li>
                    <li><a class="nav-link" href="#Números_clases_int_y_float">Números clases int y float</a></li>
                    <li><a class="nav-link" href="#Cadenas_clase_str">Cadenas clase str</a></li>
                    <li><a class="nav-link" href="#Datos_lógicos_o_booleanos_clase_bool">Datos lógicos o booleanos clase bool</a></li>
                </ul>
            <li><a class="nav-link" href="#Estructuras_de_control">Estructuras de control</a></li>
                <ul class="sub-menu">
                    <li><a class="nav-link" href="#Condicionales_if">Condicionales if</a></li>
                    <li><a class="nav-link" href="#Bucles_condicionales_while">Bucles condicionales while</a></li>
                    <li><a class="nav-link" href="#Bucles_iterativos_for">Bucles iterativos for</a></li>
                </ul>
            <li><a class="nav-link" href="#Tipos_de_datos_estructurados">Tipos de datos estructurados</a></li>
                <ul class="sub-menu">
                    <li><a class="nav-link" href="#Listas">Listas</a></li>
                    <li><a class="nav-link" href="#Tuplas">Tuplas</a></li>
                    <li><a class="nav-link" href="#Diccionarios">Diccionarios</a></li>
                </ul>
            <li><a class="nav-link" href="#Funciones">Funciones</a></li>
                <ul class="sub-menu"><li><a class="nav-link" href="#Funciones def">Funciones def</a></li>
                    <li><a class="nav-link" href="#Argumentos_por_defecto">Argumentos por defecto</a></li>
                    <li><a class="nav-link" href="#Pasar_un_número_indeterminado_de_argumentos">Pasar un número indeterminado de argumentos</a></li>
                    <li><a class="nav-link" href="#Ámbito_de_los_parámetros_y_variables_de_una_función">Ámbito de los parámetros y variables de una función</a></li>
                    <li><a class="nav-link" href="#Paso_de_argumentos_por_referencia">Paso de argumentos por referencia</a></li>
                    <li><a class="nav-link" href="#Documentación_de_funciones">Documentación de funciones</a></li>
                    <li><a class="nav-link" href="#Funciones_recursivas">Funciones recursivas</a></li>
                    <li><a class="nav-link" href="#Programación_funcional">Programación funcional</a></li>
                    <li><a class="nav-link" href="#Comprensión_de_colecciones">Comprensión de colecciones</a></li>
                </ul>
            <li><a class="nav-link" href="#Ficheros">Ficheros</a></li>
            <li><a class="nav-link" href="#Excepciones">Excepciones</a></li>
                <ul class="sub-menu">
                    <li><a class="nav-link" href="#Control_de_errores_mediante_excepciones">Control de errores mediante excepciones</a></li>
                </ul>
            <li><a class="nav-link" href="#Apéndice:_Depuración_de_código">Apéndice: Depuración de código</a></li>
                <ul class="sub-menu">
                    <li><a class="nav-link" href="#Depuración_de_programas">Depuración de programas</a></li>
                </ul>
            <li><a class="nav-link" href="#Referencias">Referencias</a></li>
        </ul>
    </nav>
    <main id="main-doc">
        <section class="main-section" id="Introducción_a_Python">
            <header>Introducción a Python</header>
            <article>
                <h2 id="Qué_es_Python">¿Qué es Python?</h2>
                <p>
                    Python es un lenguaje de programación de alto nivel multiparadigma que permite:
                </p>    
                    <ul>
                        <li>Programación imperativa
                        </li>
                        <li>Programación funcional
                        </li>
                        <li>Programación orientada a objetos
                        </li>
                    </ul>
                <p>
                    Fue creado por Guido van Rossum en 1990 aunque actualmente es desarrollado y mantenido por la Python
                    Software Foundation
                </p>    
                <h2 id="Principales_ventajas_de_Python">Principales ventajas de Python</h2>
                <p>
                    Es de código abierto (certificado por la OSI).
                    • Es interpretable y compilable.
                    • Es fácil de aprender gracias a que su sintaxis es bastante legible para los humanos.
                    • Es un lenguaje maduro (29 años).
                    • Es fácilmente extensible e integrable en otros lenguajes (C, java).
                    • Esta mantenido por una gran comunidad de desarrolladores y hay multitud de recursos para su aprendizaje.
                </p>
                <h2 id="Tipos_de_ejecución">Tipos de ejecución</h2>
                <ul>
                    <li><h3>Interpretado en la consola de Python</h3>
                        <p>Se ejecuta cada instrucción que introduce el usuario de manera interactiva.</p>
                        <code>1 > python
                            2 >>> name = "Alf"
                            3 >>> print("Hola ", name)
                            4 Hola Alf
                        </code>
                    </li>
                    <li><h3>Interpretado en fichero</h3>
                        <p>Se leen y se ejecutan una a una todas las instrucciones del fichero.</p>
                        <code>1 # Fichero hola.py
                            2 name = "Alf"
                            3 print("Hola ", name)
                        </code>
                        <code>1 > python hola.py
                            2 Hola Alf
                        </code>
                        <p>
                            También se puede hacer el fichero ejecutable indicando en la primera línea la ruta hasta el intérprete de
                            Python.
                        </p>
                        <code>1 #!/usr/bin/python3
                            2 name = "Alf"
                            3 print("Hola", name)
                        </code>
                        <code>1 > chmod +x hola.py
                            2 > ./hola.py
                            3 Hola Alf
                        </code>
                    </li>
                    <li><h3>Compilado a bytecode</h3>
                        <code>1 # Fichero hola.py
                            2 name = "Alf"
                            3 print("Hola " + name)
                        </code>
                        <code>1 > python -O -m py_compile hola.py
                            2 > python __pycache__/hola.cpython-37.pyc
                            3 Hola Alf
                        </code>
                    </li>
                    <li><h3>Compilado a ejecutable del sistema</h3>
                        <p>
                            Hay distintos paquetes que permiten compilar a un ejecutable del sistema operativo usado, por ejemplo
                            pyinstaller.
                        </p>
                        <code>1 > conda install pyinstaller
                            2 > pyinstaller hola.py
                            3 > ./dist/hola/hola
                            4 Hola Alf
                        </code>
                    </li>
                </ul>
            </article>
        </section>
        <section class="main-section" id="Hello_world">
            <header id="Hello_world">Hello world</header>
            <article>
                <p>
                    Este es un ejemplo de un simple programa que muestra la frase "Hello World".
                </p>
                <code># Este programa muestra Hello, world!
                    print('Hello, world!')
                </code>
            </article>
        </section>
        <section class="main-section" id="Tipos_de_datos_simples">
            <header>Tipos de datos simples</header>
            <article>
                <h2 id="Tipos_de_datos_primitivos_simples">Tipos de datos primitivos simples</h2>
                <ul>
                    <li>
                        <strong>Números</strong> (numbers): Secuencia de dígitos (pueden incluir el ‑ para negativos y el . para decimales) que
                        representan números.
                        Ejemplo. 0, ‑1, 3.1415.
                    </li>
                    <li>
                        <strong>Cadenas</strong> (strings): Secuencia de caracteres alfanuméricos que representan texto. Se escriben entre comillas
                        simples o dobles.
                        Ejemplo. ‘Hola’, “Adiós”.
                    </li>
                    <li>
                        <strong>Booleanos</strong> (boolean): Contiene únicamente dos elementos True y False que representan los valores
                        lógicos verdadero y falso respectivamente.
                    </li>
                </ul>
                <p>
                    Estos datos son inmutables, es decir, su valor es constante y no puede cambiar.
                </p>
                <h2 id="Tipos_de_datos_primitivos_compuestos_contenedores">Tipos de datos primitivos compuestos (contenedores)</h2>
                <ul>
                    <li>
                        <strong>Listas</strong> (lists): Colecciones de objetos que representan secuencias ordenadas de objetos de distintos tipos.
                        Se representan con corchetes y los elementos se separan por comas.
                        Ejemplo. [1, “dos”, [3, 4], True].
                    </li>
                    <li>
                        <strong>Tuplas</strong> (tuples). Colecciones de objetos que representan secuencias ordenadas de objetos de distintos
                        tipos. A diferencia de las listas son inmutables, es decir, que no cambian durante la ejecución. Se representan
                        mediante paréntesis y los elementos se separan por comas.
                        Ejemplo. (1, ‘dos’, 3)
                    </li>
                    <li>
                        <strong>Diccionarios</strong> (dictionaries): Colecciones de objetos con una clave asociada. Se representan con llaves,
                        los pares separados por comas y cada par contiene una clave y un objeto asociado separados por dos
                        puntos.
                        Ejemplo. {‘pi’:3.1416, ‘e’:2.718}.
                    </li>
                </ul>
                <h2 id="Clase_de_un_dato_type">Clase de un dato (type())</h2>
                <p>La clase a la que pertenece un dato se obtiene con el comando type()</p>
                <code>1 >>> type(1)
                    2 &lt;class 'int'&gt;
                    3 >>> type("Hola")
                    4 &lt;class 'str'&gt;
                    5 >>> type([1, "dos", [3, 4], True])
                    6 &lt;class 'list'&gt;
                    7 >>>type({'pi':3.1416, 'e':2.718})
                    8 &lt;class 'dict'&gt;
                    9 >>>type((1, 'dos', 3))
                    10 &lt;class 'tuple'&gt;
                    </code>
                <h2 id="Números_clases_int_y_float">Números (clases int y float)</h2>
                <p>
                    La clase a la que pertenece un dato se obtiene con el comando type()
                </p>
                <code>1 >>> type(1)
                    2 &lt;class 'int'>
                    3 >>> type("Hola")
                    4 &lt;class 'str'&gt;
                    5 >>> type([1, "dos", [3, 4], True])
                    6 &lt;class 'list'&gt;
                    7 >>>type({'pi':3.1416, 'e':2.718})
                    8 &lt;class 'dict'&gt;
                    9 >>>type((1, 'dos', 3))
                    10 &lt;class 'tuple'&gt;
                    </code>
                <p>
                    Secuencia de dígitos (pueden incluir el ‑ para negativos y el . para decimales) que representan números. Pueden
                    ser enteros (int) o reales (float). 
                </p>
                <code>2 &lt;class 'int'&gt;
                    3 >>> type(-2)
                    4 &lt;class 'int'&gt;
                    5 >>> type(2.3)
                    6 &lt;class 'float'&gt;
                    </code>
                <h3>Operadores aritméticos</h3>
                <ul>
                    <li>Operadores aritméticos: + (suma), - (resta), * (producto), / (cociente), // (cociente división entera), %
                        (resto división entera), ** (potencia).</li>
                </ul>
                <p>
                    Orden de prioridad de evaluación:
                </p>
                <ol>
                    <li>Funciones predefinidas</li>
                    <li>Potencias</li>
                    <li>Productos y cocientes</li>
                    <li>Sumas y restas</li> 
                </ol>
                <p>
                    Se puede saltar el orden de evaluación utilizando paréntesis ( ).
                </p>
                <code>1 >>> 2+3
                    2 5
                    3 >>> 5*-2
                    4 -10
                    5 >>> 5/2
                    6 2.5
                    7 >>> 5//2
                    8 2
                    9 >>> (2+3)**2
                    10 25
                </code>
                <h3>Operadores lógicos con números</h3>
                <p>
                    Devuelven un valor lógico o booleano.
                </p>
                <ul>
                    <li>
                        Operadores lógicos: == (igual que), > (mayor que), < (menor que), >= (mayor o igual que), <= (menor o
                        igual que), != (distinto de).
                    </li>
                </ul>
                <code>1 >>> 3==3
                    2 True
                    3 >>> 3.1&lt;=3
                    4 False
                    5 >>> -1!=1
                    6 True
                </code>
                <h2 id="Cadenas_clase_str">Cadenas (clase str)</h2>
                <p>
                    Secuencia de caracteres alfanuméricos que representan texto. Se escriben entre comillas sencillas ’ o dobles
                    ”.
                </p>
                <code>1 'Python'
                    2 "123"
                    3 'True'
                    4 # Cadena vacía
                    5 ''
                    6 # Cadena con un espacio en blanco
                    7 ' '
                    8 # Cambio de línea
                    9 '\n'
                    10 # Tabulador
                    11 '\t'
                </code>
                <h3>Acceso a los elementos de una cadena</h3>
                <p>
                    Cada carácter tiene asociado un índice que permite acceder a él.
                    <strong> (aca va una tabla)</strong>                                <!--Agregar datos en tabla  -->
                    Cadena P y t h o n
                    Índice positivo 0 1 2 3 4 5
                    Índice negativo ‑6 ‑5 ‑4 ‑3 ‑2 ‑1
                </p>
                <ul>
                    <li>c[i] devuelve el carácter de la cadena c con el índice i.</li>
                </ul>
                <p>El índice del primer carácter de la cadena es 0.</p>
                <p>También se pueden utilizar índices negativos para recorrer la cadena del final al principio.</p>    
                <p>El índice del último carácter de la cadena es ‑1.</p>    
                <code>1 >>> 'Python'[0]
                    2 'P'
                    3 >>> 'Python'[1]
                    4 'y'
                    5 >>> 'Python'[-1]
                    6 'n'
                    7 >>> 'Python'[6]
                    8 Traceback (most recent call last):
                    9 File "&lt;stdin&gt;", line 1, in &lt;module&gt;
                    10 IndexError: string index out of range
                </code>
                <h3>Subcadenas</h3>
                <ul>
                    <li>
                        c[i:j:k] : Devuelve la subcadena de c desde el carácter con el índice i hasta el carácter anterior al
                        índice j, tomando caracteres cada k.
                    </li>
                </ul>
                <code>1 >>> 'Python'[1:4]
                    2 'yth'
                    3 >>> 'Python'[1:1]
                    4 ''
                    5 >>> 'Python'[2:]
                    6 'thon'
                    7 >>> 'Python'[:-2]
                    8 'Pyth'
                    9 >>> 'Python'[:]
                    10 'Python'
                    11 >>> 'Python'[0:6:2]
                    12 'Pto'
                </code>
                <h3>Operaciones con cadenas</h3>
                    <ul>
                        <li>c1 + c2 : Devuelve la cadena resultado de concatenar las cadenas c1 y c2.</li>
                        <li>c * n : Devuelve la cadena resultado de concatenar n copias de la cadena c.</li>
                        <li>c1 in c2 : Devuelve True si c1 es una cadena concenida en c2 y False en caso contrario.</li>
                        <li>c1 not in c2 : Devuelve True si c1 es una cadena no concenida en c2 y False en caso contrario.</li>
                    </ul>
                    <code>1 >>> 'Me gusta ' + 'Python'
                        2 'Me gusta Python'
                        3 >>> 'Python' * 3
                        4 'PythonPythonPython'
                        5 >>> 'y' in 'Python'
                        6 True
                        7 >>> 'tho' in 'Python'
                        8 True
                        9 >>> 'to' not in 'Python'
                        10 True
                    </code>
                <h3>Operaciones de comparación de cadenas</h3>
                <ul>
                    <li>c1 == c2 : Devuelve True si la cadena c1 es igual que la cadena c2 y False en caso contrario.</li>
                    <li>c1 > c2 : Devuelve True si la cadena c1 sucede a la cadena c2 y False en caso contrario.</li>
                    <li>c1 &lt; c2 : Devuelve True si la cadena c1 antecede a la cadena c2 y False en caso contrario.</li>
                    <li>c1 >= c2 : Devuelve True si la cadena c1 sucede o es igual a la cadena c2 y False en caso contrario.</li>
                    <li>c1 &lt;= c2 : Devuelve True si la cadena c1 antecede o es igual a la cadena c2 y False en caso contrario.</li>
                    <li>c1 != c2 : Devuelve True si la cadena c1 es distinta de la cadena c2 y False en caso contrario.</li>
                </ul>
                <p>
                    Utilizan el orden establecido en el código ASCII.
                </p>
                <code>1 >>> 'Python' == 'python'
                    2 False
                    3 >>> 'Python' &lt; 'python'
                    4 True
                    5 >>> 'a' > 'Z'
                    6 True
                    7 >>> 'A' >= 'Z'
                    8 False
                    9 >>> '' &lt; 'Python'
                    10 True
                </code>
                <h3>Funciones de cadenas</h3>
                <ul>
                    <li>len(c) : Devuelve el número de caracteres de la cadena c.</li>
                    <li>min(c) : Devuelve el carácter menor de la cadena c.</li>
                    <li>max(c) : Devuelve el carácter mayor de la cadena c.</li>
                    <li>c.upper() : Devuelve la cadena con los mismos caracteres que la cadena c pero en mayúsculas.</li>
                    <li>c.lower() : Devuelve la cadena con los mismos caracteres que la cadena c pero en minúsculas.</li>
                    <li>c.title() : Devuelve la cadena con los mismos caracteres que la cadena c con el primer carácter en
                        mayúsculas y el resto en minúsculas.
                    </li>
                    <li>c.split(delimitador) : Devuelve la lista formada por las subcadenas que resultan de partir la
                        cadena c usando como delimitador la cadena delimitador. Si no se especifica el delimitador utiliza
                        por defecto el espacio en blanco.
                    </li>
                </ul>
                <code>1 >>> len('Python')
                    2 6
                    3 >>> min('Python')
                    4 'P'
                    5 >>> max('Python')
                    6 'y'
                    7 >>> 'Python'.upper()
                    8 'PYTHON'
                    9 >>> 'A,B,C'.split(',')
                    10 ['A', 'B', 'C']
                    11 >>> 'I love Python'.split()
                    12 ['I', 'love', 'Python']
                </code>
                <h3>Cadenas formateadas (format())</h3>
                <ul>
                    <li>c.format(valores): Devuelve la cadena c tras sustituir los valores de la secuencia valores en los
                        marcadores de posición de c. Los marcadores de posición se indican mediante llaves {} en la cadena
                        c, y el reemplazo de los valores se puede realizar por posición, indicando en número de orden del valor dentro de las llaves, o por nombre, indicando el nombre del valor, siempre y cuando los valores se pasen
                        con el formato nombre = valor.
                    </li>
                </ul>
                <code>1 >>> 'Un {} vale {} {}'.format('€', 1.12, '$')
                    2 'Un € vale 1.12 $'
                    3 >>> 'Un {2} vale {1} {0}'.format('€', 1.12, '$')
                    4 'Un $ vale 1.12 €'
                    5 >>> 'Un {moneda1} vale {cambio} {moneda2}'.format(moneda1 = '€', cambio
                    = 1.12, moneda2 = '$')
                    6 'Un € vale 1.12 $'
                </code>
                <p>Los marcadores de posición, a parte de indicar la posición de los valores de reemplazo, pueden indicar también
                    el formato de estos. Para ello se utiliza la siguiente sintaxis:</p>
                <ul>
                    <li>{:n} : Alinea el valor a la izquierda rellenando con espacios por la derecha hasta los n caracteres.</li>
                    <li>{:>n} : Alinea el valor a la derecha rellenando con espacios por la izquierda hasta los n caracteres.</li>
                    <li>{:^n} : Alinea el valor en el centro rellenando con espacios por la izquierda y por la derecha hasta los n
                        caracteres.
                    </li>
                    <li>{:nd} : Formatea el valor como un número entero con n caracteres rellenando con espacios blancos
                        por la izquierda.
                    </li>
                    <li>{:n.mf} : Formatea el valor como un número real con un tamaño de n caracteres (incluído el separador
                        de decimales) y m cifras decimales, rellenando con espacios blancos por la izquierda.
                    </li>
                </ul>
                <code>1 >>> 'Hoy es {:^10}, mañana {:10} y pasado {:>10}'.format('lunes', 'martes', 'miércoles')
                    2 'Hoy es lunes , mañana martes y pasado miércoles'
                    3 >>> 'Cantidad {:5d}'.format(12)'
                    4 'Cantidad 12'
                    5 >>> 'Pi vale {:8.4f}'.format(3.141592)
                    6 'Pi vale 3.1416'
                </code>
                <h2 id="Datos_lógicos_o_booleanos_clase_bool">Datos lógicos o booleanos (clase bool)</h2>
                <p>Contiene únicamente dos elementos True y False que representan los valores lógicos verdadero y falso respectivamente.</p>
                <p>False tiene asociado el valor 0 y True tiene asociado el valor 1.</p>
                <h3>Operaciones con valores lógicos</h3>
                <ul>
                    <li>Operadores lógicos: == (igual que), > (mayor), < (menor), >= (mayor o igual que), <= (menor o igual que),
                        != (distinto de).
                    </li>
                    <li>not b (negación) : Devuelve True si el dato booleano b es False , y False en caso contrario.</li>
                    <li>b1 and b2 : Devuelve True si los datos booleanos b1 y b2 son True, y False en caso contrario.</li>
                    <li>b1 or b2 : Devuelve True si alguno de los datos booleanos b1 o b2 son True, y False en caso contrario.</li>
                </ul>
            </article>
        </section>
        <section class="main-section" id="Estructuras_de_control">
            <header>Estructuras de control</header>
            <article>
                <h2 id="Condicionales_if">Condicionales (if)</h2>
                <div class="borde-izq">
                    <p><span class="resaltado">if</span> condición1:</p>
                    <p class="doble-ident">bloque código</p>
                    <p>elif condición2:</p>
                    <p class="doble-ident">bloque código</p>
                    <p>...</p>
                    <p><span class="resaltado">else</span></p>
                    <p class="doble-ident">bloque código</p>
                </div>
                <p>
                    Evalúa la expresión lógica condición1 y ejecuta el primer bloque de código si es True; si no, evalúa la siguientes
                    condiciones hasta llegar a la primera que es True y ejecuta el bloque de código asociado. Si ninguna
                    condición es True ejecuta el bloque de código después de else:.
                </p>
                <p>Pueden aparecer varios bloques elif pero solo uno else al final. </p>
                <p><em>Los bloques de código deben estar indentados por 4 espacios.</em></p>
                
                <p>
                    La instrucción condicional permite evaluar el estado del programa y tomar decisiones sobre qué código ejecutar
                    en función del mismo.
                </p>
                <code>1 >>> edad = 14
                    2 >>> <span class="resaltado">if</span> edad <= 18 :
                    3 ... <span class="resaltado doble-ident">print</span>('Menor')
                    4 ... <span class="resaltado">elif</span> edad > 65:
                    5 ... <span class="resaltado doble-ident">print</span>('Jubilado')
                    6 ... <span class="resaltado">else:</span>
                    7 ... <span class="resaltado doble-ident">print</span>('Activo')
                    8 ...
                    9 Menor
                    10 >>> age = 20
                    11 >>> <span class="resaltado">if</span> edad <= 18 :
                    12 ... <span class="resaltado doble-ident">print</span>('Menor')
                    13 ... <span class="resaltado">elif</span> edad > 65:
                    14 ... <span class="resaltado doble-ident">print</span>('Jubilado')
                    15 ... <span class="resaltado">else:</span>
                    16 ... <span class="resaltado doble-ident">print</span>('Activo')
                    17 ...
                    18 Activo
                </code>
                <h2 id="Bucles_condicionales_while">Bucles condicionales (while)</h2>
                <div class="borde-izq">
                    <p><span class="resaltado">while</span> condición:</p>
                    <p class="doble-ident"><em>bloque código</em></p>
                </div>
                <p>Repite la ejecución del bloque de código mientras la expresión lógica condición sea cierta.</p>
                <p>Se puede interrumpir en cualquier momento la ejecución del bloque de código con la instrucción <span class="resaltado">break</span>.</p>
                <p><em>El bloque de código debe estar indentado por 4 espacios.</em></p>
                <code>1 >>> # Pregunta al usuario por un número hasta que introduce 0.
                    2 >>> num = None
                    3 >>> while num != 0:
                    4 ... num = int(input('Introduce un número: '))
                    5 ...
                    6 Introduce un número: 2
                    7 Introduce un número: 1
                    8 Introduce un número: 0
                    9 >>>
                </code>
                <p>Alternativa:</p>
                <code>1 >>> # Pregunta al usuario por un número hasta que introduce 0.
                    2 >>> while True:
                    3 ... num = int(input('Introduce un número: '))
                    4 ... if num == 0:
                    5 ... break
                    6 ...
                    7 Introduce un número: 2
                    8 Introduce un número: 1
                    9 Introduce un número: 0
                    10 >>>
                </code>
                <h2 id="Bucles_iterativos_for">Bucles iterativos (for)</h2>
                <div class="borde-izq">
                    <p><span class="resaltado">for</span> i in secuencia:</p>
                    <p class="doble-ident">bloque código</p>
                </div>
                <p>Repite la ejecución del bloque de código para cada elemento de la secuencia secuencia, asignado dicho
                    elemento a i en cada repetición.
                </p>
                <p>Se puede interrumpir en cualquier momento la ejecución del bloque de código con la instrucción <span class="resaltado">break</span> o
                    saltar la ejecución para un determinado elemento de la secuencia con la instrucción <span class="resaltado">continue</span>.
                </p>
                <p><em>El bloque de código debe estar indentado por 4 espacios.</em></p>
                <p>Se utiliza fundamentalmente para recorrer colecciones de objetos como cadenas, listas, tuplas o diccionarios.</p>
                <p>A menudo se usan con la instrucción range:</p>
                <ul>
                    <li>range(fin) : Genera una secuencia de números enteros desde 0 hasta fin-1.</li>
                    <li>range(inicio, fin, salto) : Genera una secuencia de números enteros desde inicio hasta
                        fin-1 con un incremento de salto.
                    </li>
                </ul>
                <code>1 >>> palabra = 'Python'
                    2 >>> <span class="resaltado">for</span> letra <span class="resaltado">in</span> palabra:
                    3 ... <span class="resaltado doble-ident"></span>print(letra)
                    4 ...
                    5 P
                    6 y
                    7 t
                    8 h
                    9 o
                    10 n
                </code>
                <code>1 >>> <span class="resaltado">for</span> i in <span class="resaltado2">range</span>(1, 10, 2):
                    2 ... <span class="resaltado doble-ident">print</span>(i, end=", ")
                    3 ...
                    4 1, 3, 5, 7, 9, >>>
                </code>
            </article>
        </section>
        <section class="main-section" id="Tipos_de_datos_estructurados">
            <header>Tipos de datos estructurados</header>
            <article>
                <h2 id="Listas">Listas</h2>
                <p>Una <strong>lista</strong> es una secuencias ordenadas de objetos de distintos tipos.</p>
                <p>Se construyen poniendo los elementos entre corchetes [ ] separados por comas.</p>
                <p>Se caracterizan por:</p>
                <ul>
                    <li>Tienen orden.</li>
                    <li>Pueden contener elementos de distintos tipos.</li>
                    <li>Son mutables, es decir, pueden alterarse durante la ejecución de un programa.</li>
                </ul>
                <code>1 # Lista vacía
                    2 >>> <span class="resaltado2">type</span>([])
                    3 &lt;<span class="resaltado">class</span> 'list'>
                    4 # Lista con elementos de distintos tipos
                    5 >>> [1, "dos", True]
                    6 # Listas anidadas
                    7 >>> [1, [2, 3], 4]
                </code>
                <h3>Creación de listas mediante la función list()</h3>
                <p>Otra forma de crear listas es mediante la función list().</p>
                <ul>
                    <li>list(c) : Crea una lista con los elementos de la secuencia o colección c.</li>
                </ul>
                <p>Se pueden indicar los elementos separados por comas, mediante una cadena, o mediante una colección de
                    elementos iterable.
                </p>
                <code>1 >>> <span class="resaltado2">list</span>()
                    2 []
                    3 >>> <span class="resaltado2">list</span>(1, 2, 3)
                    4 [1, 2, 3]
                    5 >>> <span class="resaltado2">list</span>("Python")
                    6 ['P', 'y', 't', 'h', 'o', 'n']</code>
                <h3>Acceso a los elementos de una lista</h3>
                <p>Se utilizan los mismos operadores de acceso que para cadenas de caracteres.</p>
                <ul>
                    <li>l[i] : Devuelve el elemento de la lista l con el índice i.</li>
                </ul>
                <p>El índice del primer elemento de la lista es 0.</p>
                <code>1 >>> a = ['P', 'y', 't', 'h', 'o', 'n']
                    2 >>> a[0]
                    3 'P'
                    4 >>> a[5]
                    5 'n'
                    6 >>> a[6]
                    7 Traceback (most recent call last):
                    8 File "&lt;stdin>", line 1, <span class="resaltado">in</span> &lt;module>
                    9 IndexError: <span class="resaltado2">list</span> index out of <span class="resaltado2">range</span>
                    10 >>> a[-1]
                    11 'n'    
                    </code>
                    <h3>Sublistas</h3>
                    <ul>
                        <li>
                            l[i:j:k] : Devuelve la sublista desde el elemento de l con el índice i hasta el elemento anterior al
                            índice j, tomando elementos cada k. 
                        </li>
                    </ul>
                    <code>1 >>> a = ['P', 'y', 't', 'h', 'o', 'n']
                        2 >>> a[1:4]
                        3 ['y', 't', 'h']
                        4 >>> a[1:1]
                        5 []
                        6 >>> a[:-3]
                        7 ['y', 't', 'h']
                        8 >>> a[:]
                        9 ['P', 'y', 't', 'h', 'o', 'n']
                        10 >>> a[0:6:2]
                        11 ['P', 't', 'o']
                    </code>
                    <h3>Operaciones que no modifican una lista</h3>
                    <ul>
                        <li>len(l) : Devuelve el número de elementos de la lista l.</li>
                        <li>min(l) : Devuelve el mínimo elemento de la lista l siempre que los datos sean comparables.</li>
                        <li>max(l) : Devuelve el máximo elemento de la lista l siempre que los datos sean comparables.</li>
                        <li>sum(l) : Devuelve la suma de los elementos de la lista l, siempre que los datos se puedan sumar.</li>
                        <li>dato in l : Devuelve True si el dato dato pertenece a la lista l y False en caso contrario.</li>
                        <li>l.index(dato) : Devuelve la posición que ocupa en la lista l el primer elemento con valor dato.</li>
                        <li>l.count(dato) : Devuelve el número de veces que el valor dato está contenido en la lista l.</li>
                        <li>all(l) : Devuelve True si todos los elementos de la lista l son True y False en caso contrario.</li>
                        <li>any(l) : Devuelve True si algún elemento de la lista l es True y False en caso contrario.</li>
                    </ul>
                    <code>1 >>> a = [1, 2, 2, 3]
                        2 >>> <span class="resaltado2">len</span>(a)
                        3 4
                        4 >>> <span class="resaltado2">min</span>(a)
                        5 1
                        6 >>> <span class="resaltado2">max</span>(a)
                        7 3
                        8 >>> <span class="resaltado2">sum</span>(a)
                        9 8
                        10 >>> 3 <span class="resaltado">in</span> a
                        11 True
                        12 >>> a.index(2)
                        13 1
                        14 >>> a.count(2)
                        15 2
                        16 >>> <span class="resaltado2">all</span>(a)
                        17 True
                        18 >>> <span class="resaltado2">any</span>([0, False, 3&lt;2])
                        19 False
                    </code>
                    <h3>Operaciones que modifican una lista</h3>
                    <ul>
                        <li>l1 + l2 : Crea una nueva lista concatenan los elementos de la listas l1 y l2.</li>
                        <li>l.append(dato) : Añade dato al final de la lista l.</li>
                        <li>l.extend(sequencia) : Añade los datos de sequencia al final de la lista l.</li>
                        <li>l.insert(índice, dato) : Inserta dato en la posición índice de la lista l y desplaza los elementos
                            una posición a partir de la posición índice.
                        </li>
                        <li>l.remove(dato) : Elimina el primer elemento con valor dato en la lista l y desplaza los que están
                            por detrás de él una posición hacia delante.
                        </li>
                        <li>l.pop([índice]) : Devuelve el dato en la posición índice y lo elimina de la lista l, desplazando
                            los elementos por detrás de él una posición hacia delante.
                        </li>
                        <li>l.sort() : Ordena los elementos de la lista l de acuerdo al orden predefinido, siempre que los elementos
                            sean comparables.
                        </li>
                        <li>l.reverse() : invierte el orden de los elementos de la lista l.</li>
                    </ul>
                    <code>1 >>> a = [1, 3]
                        2 >>> b = [2 , 4, 6]
                        3 >>> a.append(5)
                        4 >>> a
                        5 [1, 3, 5]
                        6 >>> a.remove(3)
                        7 >>> a
                        8 [1, 5]
                        9 >>> a.insert(1, 3)
                        10 >>> a
                        11 [1, 3, 5]
                        12 >>> b.pop()
                        13 6
                        14 >>> c = a + b
                        15 >>> c
                        16 [1, 3, 5, 2, 4]
                        17 >>> c.sort()
                        18 >>> c
                        19 [1, 2, 3, 4, 5]
                        20 >>> c.reverse()
                        21 >>> c
                        22 [5, 4, 3, 2, 1]
                    </code>
                    <h3>Copia de listas</h3>
                    <p>Existen dos formas de copiar listas:</p>
                    <ul>
                        <li><strong>Copia por referencia</strong> l1 = l2: Asocia la la variable l1 la misma lista que tiene asociada la variable l2,
                            es decir, ambas variables apuntan a la misma dirección de memoria. Cualquier cambio que hagamos a
                            través de l1 o l2 afectará a la misma lista.
                        </li>
                        <li><strong>Copia por valor</strong> l1 = list(l2): Crea una copia de la lista asociada a l2 en una dirección de memoria
                            diferente y se la asocia a l1. Las variables apuntan a direcciones de memoria diferentes que contienen
                            los mismos datos. Cualquier cambio que hagamos a través de l1 no afectará a la lista de l2 y viceversa.
                        </li>
                    </ul>
                    <code>1 >>> a = [1, 2, 3]
                        2 >>> # copia por referencia
                        3 >>> b = a
                        4 >>> b
                        5 [1, 2, 3]
                        6 >>> b.remove(2)
                        7 >>> b
                        8 [1, 3]
                        9 >>> a
                        10 [1, 3]
                    </code>
                    <code>1 >>> a = [1, 2, 3]
                        2 >>> # copia por referencia
                        3 >>> b = <span class="resaltado2">list</span>(a)
                        4 >>> b
                        5 [1, 2, 3]
                        6 >>> b.remove(2)
                        7 >>> b
                        8 [1, 3]
                        9 >>> a
                        10 [1, 2, 3]
                    </code>
                    <h2 id="Tuplas">Tuplas</h2>
                    <p>Una <strong>tupla</strong> es una secuencias ordenadas de objetos de distintos tipos.</p> 
                    <p>Se construyen poniendo los elementos entre corchetes ( ) separados por comas.</p>
                    <p>Se caracterizan por:</p>
                    <ul>
                        <li>Tienen orden.</li>
                        <li>Pueden contener elementos de distintos tipos.</li>
                        <li>Son inmutables, es decir, no pueden alterarse durante la ejecución de un programa.</li>
                    </ul>
                    <p>Se usan habitualmente para representar colecciones de datos una determinada estructura semántica, como
                        por ejemplo un vector o una matriz.
                    </p>
                    <code>1 # Tupla vacía
                        2 <span class="resaltado2">type</span>(())
                        3 &lt;<span class="resaltado">class</span> 'tuple'>
                        4 # Tupla con elementos de distintos tipos
                        5 (1, "dos", True)
                        6 # Vector
                        7 (1, 2, 3)
                        8 # Matriz
                        9 ((1, 2, 3), (4, 5, 6))
                    </code>
                    <h3>Creación de tuplas mediante la función tuple()</h3>
                    <p>Otra forma de crear tuplas es mediante la función tuple().</p>
                    <ul>
                        <li>tuple(c) : Crea una tupla con los elementos de la secuencia o colección c.</li>
                    </ul>
                    <p>Se pueden indicar los elementos separados por comas, mediante una cadena, o mediante una colección de
                        elementos iterable.
                    </p>
                    <code>1 >>> <span class="resaltado">tuple</span>()
                        2 ()
                        3 >>> <span class="resaltado">tuple</span>(1, 2, 3)
                        4 (1, 2, 3)
                        5 >>> <span class="resaltado">tuple</span>("Python")
                        6 ('P', 'y', 't', 'h', 'o', 'n')
                        7 >>> <span class="resaltado">tuple</span>([1, 2, 3])
                        8 (1, 2, 3)
                    </code>
                    <h3>Operaciones con tuplas</h3>
                    <p>El acceso a los elementos de una tupla se realiza del mismo modo que en las listas. También se pueden obtener
                        subtuplas de la misma manera que las sublistas.
                    </p>
                    <p>Las operaciones de listas que no modifican la lista también son aplicables a las tuplas.</p>
                    <code>1 >>> a = (1, 2, 3)
                        2 >>> a[1]
                        3 2
                        4 >>> <span class="resaltado2">len</span>(a)
                        5 3
                        6 >>> a.index(3)
                        7 2
                        8 >>> 0 <span class="resaltado">in</span> a
                        9 False
                        10 >>> b = ((1, 2, 3), (4, 5, 6))
                        11 >>> b[1]
                        12 (4, 5, 6)
                        13 >>> b[1][2]
                        14 6
                    </code>
                    <h2 id="Diccionarios">Diccionarios</h2>
                    <p>Un diccionario es una colección de pares formados por una clave y un valor asociado a la clave.</p>
                    <p>Se construyen poniendo los pares entre llaves { } separados por comas, y separando la clave del valor con
                        dos puntos :.
                    </p>
                    <p>Se caracterizan por:</p>
                    <ul>
                        <li>No tienen orden.</li>
                        <li>Pueden contener elementos de distintos tipos.</li>
                        <li>Son mutables, es decir, pueden alterarse durante la ejecución de un programa.</li>
                        <li>Las claves son únicas, es decir, no pueden repetirse en un mismo diccionario, y pueden ser de cualquier
                            tipo de datos inmutable.</li>
                    </ul>
                    <code>1 # Diccionario vacío
                        2 <span class="resaltado2">type</span>({})
                        3 &lt;<span class="resaltado">class</span> 'dict'>
                        4 # Diccionario con elementos de distintos tipos
                        5 {'nombre':'Alfredo', 'despacho': 218, 'email':'asalber@ceu.es'}
                        6 # Diccionarios anidados
                        7 {'nombre_completo':{'nombre': 'Alfredo', 'Apellidos': 'Sánchez Alberca'}}
                    </code>
                    <h3>Acceso a los elementos de un diccionario</h3>
                    <ul>
                        <li>d[clave] devuelve el valor del diccionario d asociado a la clave clave. Si en el diccionario no existe
                            esa clave devuelve un error.
                        </li>
                        <li>d.get(clave, valor) devuelve el valor del diccionario d asociado a la clave clave. Si en el diccionario
                            no existe esa clave devuelve valor, y si no se especifica un valor por defecto devuelve None.
                        </li>
                    </ul>
                    <code>1 >>> a = {'nombre':'Alfredo', 'despacho': 218, 'email':'asalber@ceu.es'}
                        2 >>> a['nombre']
                        3 'Alfredo'
                        4 >>> a['despacho'] = 210
                        5 >>> a
                        6 {'nombre':'Alfredo', 'despacho': 218, 'email':'asalber@ceu.es'}
                        7 >>> a.get('email')
                        8 'asalber@ceu.es'
                        9 >>> a.get('universidad', 'CEU')
                        10 'CEU'
                    </code>
                    <h3>Operaciones que no modifican un diccionario</h3>
                    <ul>
                        <li>len(d) : Devuelve el número de elementos del diccionario d.</li>
                        <li>min(d) : Devuelve la mínima clave del diccionario d siempre que las claves sean comparables.</li>
                        <li>max(d) : Devuelve la máxima clave del diccionario d siempre que las claves sean comparables.</li>
                        <li>sum(d) : Devuelve la suma de las claves del diccionario d, siempre que las claves se puedan sumar.</li>
                        <li>clave in d : Devuelve True si la clave clave pertenece al diccionario d y False en caso contrario.</li>
                        <li>d.keys() : Devuelve un iterador sobre las claves de un diccionario.</li>
                        <li>d.values() : Devuelve un iterador sobre los valores de un diccionario.</li>
                        <li>d.items() : Devuelve un iterador sobre los pares clave‑valor de un diccionario.</li>
                    </ul>
                    <code>1 >>> a = {'nombre':'Alfredo', 'despacho': 218, 'email':'asalber@ceu.es'}
                        2 >>> <span class="resaltado2">len</span>(a)
                        3 3
                        4 >>> <span class="resaltado2">min</span>(a)
                        5 'despacho'
                        6 >>> 'email' <span class="resaltado">in</span> a
                        7 True
                        8 >>> a.keys()
                        9 dict_keys(['nombre', 'despacho', 'email'])
                        10 >>> a.values()
                        11 dict_values(['Alfredo', 218, 'asalber@ceu.es'])
                        12 >>> a.items()
                        13 dict_items([('nombre', 'Alfredo'), ('despacho', 218), ('email', '
                        asalber@ceu.es')])
                    </code>
                    <h3>Operaciones que modifican un diccionario</h3>
                    <ul>
                        <li>d[clave] = valor : Añade al diccionario d el par formado por la clave clave y el valor valor.</li>
                        <li>d.update(d2). Añade los pares del diccionario d2 al diccionario d.</li>
                        <li>d.pop(clave, alternativo) : Devuelve del valor asociado a la clave clave del diccionario d y
                            lo elimina del diccionario. Si la clave no está devuelve el valor alternativo.
                        </li>
                        <li>d.popitem() : Devuelve la tupla formada por la clave y el valor del último par añadido al diccionario
                            d y lo elimina del diccionario.
                        </li>
                        <li>del d[clave] : Elimina del diccionario d el par con la clave clave.</li>
                        <li>d.clear() : Elimina todos los pares del diccionario d de manera que se queda vacío.</li>
                    </ul>
                    <code>1 >>> a = {'nombre':'Alfredo', 'despacho': 218, 'email':'asalber@ceu.es'}
                        2 >>> a['universidad'] = 'CEU'
                        3 >>> a
                        4 {'nombre': 'Alfredo', 'despacho': 218, 'email': 'asalber@ceu.es', '
                        universidad': 'CEU'}
                        5 >>> a.pop('despacho')
                        6 218
                        7 >>> a
                        8 {'nombre': 'Alfredo', 'email': 'asalber@ceu.es', 'universidad': 'CEU'}
                        9 >>> a.popitem()
                        10 ('universidad', 'CEU')
                        11 >>> a
                        12 {'nombre': 'Alfredo', 'email': 'asalber@ceu.es'}
                        13 >>> <span class="resaltado">del</span> a['email']
                        14 >>> a
                        15 {'nombre': 'Alfredo'}
                        16 >>> a.clear()
                        17 >>> a
                        18 {}
                    </code>
                    <h3>Copia de diccionarios</h3>
                    <p>Existen dos formas de copiar diccionarios:</p>
                    <ul>
                        <li><strong>Copia por referencia</strong> d1 = d2: Asocia la la variable d1 el mismo diccionario que tiene asociado la
                            variable d2, es decir, ambas variables apuntan a la misma dirección de memoria. Cualquier cambio que
                            hagamos a través de l1 o l2 afectará al mismo diccionario.
                        </li>
                        <li><strong>Copia por valor</strong> d1 = list(d2): Crea una copia del diccionario asociado a d2 en una dirección de
                            memoria diferente y se la asocia a d1. Las variables apuntan a direcciones de memoria diferentes que
                            contienen los mismos datos. Cualquier cambio que hagamos a través de l1 no afectará al diccionario
                            de l2 y viceversa.
                        </li>
                    </ul>
                    <code>1 >>> a = {1:'A', 2:'B', 3:'C'}
                        2 >>> # copia por referencia
                        3 >>> b = a
                        4 >>> b
                        5 {1:'A', 2:'B', 3:'C'}
                        6 >>> b.pop(2)
                        7 >>> b
                        8 {1:'A', 3:'C'}
                        9 >>> a
                        10 {1:'A', 3:'C'}
                    </code>
                    <code>1 >>> a = {1:'A', 2:'B', 3:'C'}
                        2 >>> # copia por referencia
                        3 >>> b = <span class="resaltado2">dict</span>(a)
                        4 >>> b
                        5 {1:'A', 2:'B', 3:'C'}
                        6 >>> b.pop(2)
                        7 >>> b
                        8 {1:'A', 3:'C'}
                        9 >>> a
                        10 {1:'A', 2:'B', 3:'C'}
                    </code>
            </article>
        </section>
        <section class="main-section" id="Funciones">
            <header>Funciones</header>
            <article>
                <h2 id="Funciones def">Funciones (def)</h2>
                <p>Una función es un bloque de código que tiene asociado un nombre, de manera que cada vez que se quiera
                    ejecutar el bloque de código basta con invocar el nombre de la función.
                </p>
                <p>Para declarar una función se utiliza la siguiente sintaxis:</p>
                <div class="borde-izq">
                    <p>def &lt;nombre-funcion> (&lt;parámetros>):</p>
                    <p class="doble-ident">bloque código</p>
                    <p class="doble-ident"><span class="resaltado">return</span> &lt;objeto></p>
                </div>
                <code>1 >>> <span class="resaltado">def</span> bienvenida():
                    2 ... <span class="resaltado doble-ident">print</span>('¡Bienvenido a Python!')
                    3 ... <span class="resaltado doble-ident">return</span>
                    4 ...
                    5 >>> <span class="resaltado2">type</span>(bienvenida)
                    6 &lt;<span class="resaltado">class</span> 'function'>
                    7 >>> bienvenida()
                    8 ¡Bienvenido a Python!
                </code>
                <h3>Parámetros de una función</h3>
                <p>Una función puede recibir valores cuando se invoca a través de unas variables conocidas como parámetros
                    que se definen entre paréntesis en la declaración de la función. En el cuerpo de la función se pueden usar estos
                    parámetros como si fuesen variables.
                </p>
                <code>1 >>> <span class="resaltado">def</span> bienvenida(nombre):
                    2 ... <span class="resaltado doble-ident">print</span>('¡Bienvenido a Python', nombre + '!')
                    3 ... <span class="resaltado doble-ident">return</span>
                    4 ...
                    5 >>> bienvenida('Alf')
                    6 ¡Bienvenido a Python Alf!
                </code>
                <h3>Argumentos de la llamada a una función</h3>
                <p>Los valores que se pasan a la función en una llamada o invocación concreta de ella se conocen como argumentos
                    y se asocian a los parámetros de la declaración de la función.
                </p>
                <p>Los argumentos se pueden indicar de dos formas:</p>
                <ul>
                    <li><strong>Argumentos posicionales</strong>: Se asocian a los parámetros de la función en el mismo orden que aparecen
                        en la definición de la función.</li>
                        <li><strong>Argumentos por nombre</strong>: Se indica explícitamente el nombre del parámetro al que se asocia un argumento
                        de la forma parametro = argumento.</li>
                </ul>
                <code>1 >>> <span class="resaltado">def</span> bienvenida(nombre, apellido):
                    2 ... <span class="resaltado doble-ident">print</span>('¡Bienvenido a Python', nombre, apellido + '!')
                    3 ... <span class="resaltado doble-ident">return</span>
                    4 ...
                    5 >>> bienvenida('Alfredo', 'Sánchez)
                    6 ¡Bienvenido a Python Alfredo Sánchez!
                    7 >>> bienvenida(apellido = 'Sánchez', nombre = 'Alfredo')
                    8 ¡Bienvenido a Python Alfredo Sánchez!
                </code>
                <h3>Retorno de una función</h3>
                <p>Una función puede devolver un objeto de cualquier tipo tras su invocación. Para ello el objeto a devolver debe
                    escribirse detrás de la palabra reservada <span class="resaltado">return</span>. Si no se indica ningún objeto, la función no devolverá
                    nada.
                </p>
                <code>1 >>> <span class="resaltado">def</span> area_triangulo(base, altura):
                    2 ... <span class="resaltado doble-ident">return</span> base * altura / 2
                    3 ...
                    4 >>> area_triangulo(2, 3)
                    5 3
                    6 >>> area_triangulo(4, 5)
                    7 10
                </code>
                <h2 id="Argumentos_por_defecto">Argumentos por defecto</h2>
                <p>En la definición de una función se puede asignar a cada parámetro un argumento por defecto, de manera que
                    si se invoca la función sin proporcionar ningún argumento para ese parámetro, se utiliza el argumento por
                    defecto.
                </p>
                <code>1 >>> <span class="resaltado">def</span> bienvenida(nombre, lenguaje = 'Python'):
                    2 ... <span class="resaltado doble-ident">print</span>('¡Bienvenido a', lenguaje, nombre + '!')
                    3 ... <span class="resaltado doble-ident">return</span>
                    4 ...
                    5 >>> bienvenida('Alf')
                    6 ¡Bienvenido a Python Alf!
                    7 >>> bienvenida('Alf', 'Java')
                    8 ¡Bienvenido a Java Alf!
                </code>
                <h2 id="Pasar_un_número_indeterminado_de_argumentos">Pasar un número indeterminado de argumentos</h2>
                <p>Por último, es posible pasar un número variable de argumentos a un parámetro. Esto se puede hacer de dos
                    formas:
                </p>
                <ul>
                    <li>*parametro: Se antepone un asterisco al nombre del parámetro y en la invocación de la función se
                        pasa el número variable de argumentos separados por comas. Los argumentos se guardan en una lista
                        que se asocia al parámetro.
                    </li>
                    <li>**parametro: Se anteponen dos asteriscos al nombre del parámetro y en la invocación de la función
                        se pasa el número variable de argumentos por pares nombre = valor, separados por comas. Los
                        argumentos se guardan en un diccionario que se asocia al parámetro.
                    </li>
                </ul>
                <code>1 >>> <span class="resaltado">def</span> menu(*platos):
                    2 ... <span class="resaltado doble-ident">print</span>('Hoy tenemos: ', end='')
                    3 ... <span class="resaltado doble-ident"><span class="doble-ident">for</span></span> plato <span class="resaltado">in</span> platos:
                    4 ... <span class="resaltado doble-ident">print</span>(plato, end=', ')
                    5 ... <span class="resaltado doble-ident">return</span>
                    6 ...
                    7 >>> menu('pasta', 'pizza', 'ensalada')
                    8 Hoy tenemos: pasta, pizza, ensalada,
                </code>
                <h2 id="Ámbito_de_los_parámetros_y_variables_de_una_función">Ámbito de los parámetros y variables de una función</h2>
                <p>Los parámetros y las variables declaradas dentro de una función son de <strong>ámbito local</strong>, mientras que las definidas
                    fuera de ella son de ámbito <strong>ámbito global</strong>.
                </p>
                <p>Tanto los parámetros como las variables del ámbito local de una función sólo están accesibles durante la ejecución
                    de la función, es decir, cuando termina la ejecución de la función estas variables desaparecen y no son
                    accesibles desde fuera de la función.
                </p>
                <code>1 >>>  <span class="resaltado">def</span> bienvenida(nombre):
                    2 ... lenguaje = 'Python'
                    3 ... <span class="resaltado doble-ident">print</span>('¡Bienvenido a', lenguaje, nombre + '!')
                    4 ... <span class="resaltado doble-ident">return</span>
                    5 ...
                    6 >>> bienvenida('Alf')
                    7 ¡Bienvenido a Python Alf!
                    8 >>> lenguaje
                    9 Traceback (most recent call last):
                    10 File "&lt;stdin>", line 1, <span class="resaltado">in</span> &lt;module>
                    11 NameError: name 'lenguaje' <span class="resaltado">is not</span> defined
                </code>
                <p>Si en el ámbito local de una función existe una variable que también existe en el ámbito global, durante la ejecución
                    de la función la variable global queda eclipsada por la variable local y no es accesible hasta que finaliza
                    la ejecución de la función.
                </p>
                <code>1 >>> lenguaje = 'Java'
                    2 >>> <span class="resaltado">def</span> bienvenida():
                    3 ... lenguaje = 'Python'
                    4 ... <span class="resaltado doble-ident">print</span>('¡Bienvenido a', lenguaje + '!')
                    5 ... <span class="resaltado doble-ident">return</span>
                    6 ...
                    7 >>> bienvenida()
                    8 ¡Bienvenido a Python!
                    9 >>> <span class="resaltado">print</span>(lenguaje)
                    10 Java
                </code>
                <h2 id="Paso_de_argumentos_por_referencia">Paso de argumentos por referencia</h2>
                <p>En Python el paso de argumentos a una función es siempre por referencia, es decir, se pasa una referencia al objeto
                    del argumento, de manera que cualquier cambio que se haga dentro de la función mediante el parámetro
                    asociado afectará al objeto original, siempre y cuando este sea mutable.
                </p>
                <code>1 >>> primer_curso = ['Matemáticas', 'Física']
                    2 >>> <span class="resaltado">def</span> añade_asignatura(curso, asignatura):
                    3 ... <span class="doble-ident">curso.append(asignatura)</span>
                    4 ... <span class="resaltado doble-ident">return</span>
                    5 ...
                    6 >>> añade_asignatura(primer_curso, 'Química')
                    7 >>> <span class="resaltado">print</span>(primer_curso)
                    8 ['Matemáticas', 'Física', 'Química']
                </code>
                <h2 id="Documentación_de_funciones">Documentación de funciones</h2>
                <p>Una práctica muy recomendable cuando se define una función es describir lo que la función hace en un comentario.</p> 
                <p>En Python esto se hace con un <strong>docstring</strong> que es un tipo de comentario especial se hace en la línea siguiente al
                    encabezado de la función entre tres comillas simples ''' o dobles """.
                </p>
                <p>Después se puede acceder a la documentación de la función con la función help(<nombre-función>).</p>
                <code>1 >>> <span class="resaltado">def</span> area_triangulo(base, altura):
                    2 ... <span class="comentario">"""Función que calcula el área de un triángulo.</span>
                    3 <span class="comentario">...</span>
                    4 <span class="comentario">... Parámetros:</span>
                    5 <span class="comentario">... </span><span class="doble-ident comentario">- base: La base del triángulo.</span>
                    6 <span class="comentario">... </span><span class="doble-ident comentario">- altura: La altura del triángulo.</span>
                    7 <span class="comentario">... Resultado:</span>
                    8 <span class="comentario">... </span><span class="doble-ident comentario">El área del triángulo con la base y altura especificadas.</span>
                    9 <span class="comentario">... """</span>
                    10 ... <span class="resaltado doble-ident">return</span> base * altura / 2
                    11 ...
                    12 >>> <span class="resaltado2">help</span>(area_triangulo)
                    13 area_triangulo(base, altura)
                    14 <span class="doble-ident">Función que calcula el área de un triángulo.</span>
                    15
                    16 Parámetros:
                    17 <span class="doble-ident">- base: La base <span class="resaltado">del</span> triángulo.</span>
                    18 <span class="doble-ident">- altura: La altura <span class="resaltado">del</span> triángulo.</span>
                    19 Resultado:
                    20 <span class="doble-ident">El área <span class="resaltado">del</span> triángulo con la base y altura especificadas.</span>
                </code>
                <h2 id="Funciones_recursivas">Funciones recursivas</h2>
                <p>Una función recursiva es una función que en su cuerpo contiene una llama a si misma.</p>
                <p>La recursión es una práctica común en la mayoría de los lenguajes de programación ya que permite resolver
                    las tareas recursivas de manera más natural.
                </p>
                <p>Para garantizar el final de una función recursiva, las sucesivas llamadas tienen que reducir el grado de complejidad
                    del problema, hasta que este pueda resolverse directamente sin necesidad de volver a llamar a la
                    función.
                </p>
                <code>1 >>> <span class="resaltado">def</span> factorial(n):
                    2 ... <span class="resaltado doble-ident">if</span> n == 0:
                    3 ... <span class="doble-ident"><span class="resaltado doble-ident">return</span> 1</span>
                    4 ... <span class="resaltado doble-ident">else:</span>
                    5 ... <span class="doble-ident"><span class="resaltado doble-ident">return</span> n * factorial(n-1)</span>
                    6 ...
                    7 >>> f(5)
                    8 120
                </code>
                <h3>Funciones recursivas múltiples</h3>
                <p>Una función recursiva puede invocarse a si misma tantas veces como quiera en su cuerpo.</p>
                <code>1 >>> <span class="resaltado">def</span> fibonacci(n):
                    2 ... <span class="resaltado doble-ident">if</span> n &lt;= 1:
                    3 ... <span class="doble-ident"><span class="resaltado doble-ident">return</span> n</span>
                    4 ... <span class="resaltado doble-ident">else:</span>
                    5 ... <span class="doble-ident"><span class="resaltado doble-ident">return</span> fibonacci(n - 1) + fibonacci(n - 2)</span>
                    6 ...
                    7 >>> fibonacci(6)
                    8 8
                </code>
                <h3>Los riesgos de la recursión</h3>
                <p>Aunque la recursión permite resolver las tareas recursivas de forma más natural, hay que tener cuidado con ella
                    porque suele consumir bastante memoria, ya que cada llamada a la función crea un nuevo ámbito local con las
                    variables y los parámetros de la función.
                </p>
                <p>En muchos casos es más eficiente resolver la tarea recursiva de forma iterativa usando bucles.</p>
                <code>1 >>> <span class="resaltado">def</span> fibonacci(n):
                    2 ... <span class="doble-ident">a, b = 0, 1</span>
                    3 ... <span class="doble-ident">for i <span class="resaltado">in</span> <span class="resaltado2">range</span>(n):</span>
                    4 ... <span class="doble-ident"><span class="doble-ident">a, b = b, a + b</span></span>
                    5 ... <span class="resaltado doble-ident">return</span> a
                    6 ...
                    7 >>> fibonacci(6)
                    8 8
                </code>
                <h2 id="Programación_funcional">Programación funcional</h2>
                <p>En Python las funciones son objetos de primera clase, es decir, que pueden pasarse como argumentos de una
                    función, al igual que el resto de los tipos de datos.
                </p>
                <code>1 >>> <span class="resaltado">def</span> aplica(funcion, argumento):
                    2 ... <span class="resaltado doble-ident">return</span> funcion(argumento)
                    3 ...
                    4 >>> <span class="resaltado">def</span> cuadrado(n):
                    5 ... <span class="resaltado doble-ident">return</span> n*n
                    6 ...
                    7 >>> <span class="resaltado">def</span> cubo(n):
                    8 ... <span class="resaltado doble-ident">return</span> n**3
                    9 ...
                    10 >>> aplica(cuadrado, 5)
                    11 25
                    12 >>> aplica(cubo, 5)
                    13 125
                </code>
                <h3>Funciones anónimas (lambda)</h3>
                <p>Existe un tipo especial de funciones que no tienen nombre asociado y se conocen como <strong>funciones anónimas</strong>
                    o <strong>funciones lambda</strong>.
                </p>
                <p>La sintaxis para definir una función anónima es</p>
                <div class="borde-izq">
                    <p>
                        lambda &lt;parámetros> : &lt;expresión>&lt;/expresi>
                    </p>
                </div>
                <p>Estas funciones se suelen asociar a una variable o parámetro desde la que hacer la llamada.</p>
                <code>1 >>> area = <span class="resaltado">lambda</span> base, altura : base * altura
                    2 >>> area(4, 5)
                    3 10
                </code>
                <h3>Aplicar una función a todos los elementos de una colección iterable (map)</h3>
                <p>map(f, c) : Devuelve una objeto iterable con los resultados de aplicar la función f a los elementos de la
                    colección c. Si la función f requiere n argumentos entonces deben pasarse n colecciones con los argumentos.
                    Para convertir el objeto en una lista, tupla o diccionario hay que aplicar explícitamente las funciones list(),
                    tuple() o dic() respectivamente.
                </p>
                <code>1 >>> <span class="resaltado">def</span> cuadrado(n):
                    2 ... <span class="resaltado doble-ident">return</span> n * n
                    3 ...
                    4 >>> <span class="resaltado2">list</span>(<span class="resaltado2">map</span>(cuadrado, [1, 2, 3])
                    5 [1, 4, 9]
                </code>
                <code>1 >>> <span class="resaltado">def</span> rectangulo(a, b):
                    2 ... <span class="resaltado doble-ident">return</span> a * b
                    3 ...
                    4 >>> <span class="resaltado2">tuple</span>(<span class="resaltado2">map</span>(rectangulo, (1, 2, 3), (4, 5, 6)))
                    5 (4, 10, 18)
                </code>
                <h3>Filtrar los elementos de una colección iterable (filter)</h3>
                <p>filter(f, c) : Devuelve una objeto iterable con los elementos de la colección c que devuelven True al
                    aplicarles la función f. Para convertir el objeto en una lista, tupla o diccionario hay que aplicar explícitamente
                    las funciones list(), tuple() o dic() respectivamente.
                </p>
                <p>f debe ser una función que recibe un argumento y devuelve un valor booleano.</p>
                <code>1 >>> <span class="resaltado">def</span> par(n):
                    2 ... <span class="resaltado doble-ident">return</span> n % 2 == 0
                    3 ...
                    4 >>> <span class="resaltado2">list</span>(<span class="resaltado2">filter</span>(par, <span class="resaltado2">range</span>(10))
                    5 [0, 2, 4, 6, 8]
                </code>
                <h3>Combinar los elementos de varias colecciones iterables (zip)</h3>
                <p>zip(c1, c2, ...) : Devuelve un objeto iterable cuyos elementos son tuplas formadas por los elementos
                    que ocupan la misma posición en las colecciones c1, c2, etc. El número de elementos de las tuplas es el número
                    de colecciones que se pasen. Para convertir el objeto en una lista, tupla o diccionario hay que aplicar
                    explícitamente las funciones list(), tuple() o dic() respectivamente.
                </p>
                <code>1 >>> asignaturas = ['Matemáticas', 'Física', 'Química', 'Economía']
                    2 >>> notas = [6.0, 3.5, 7.5, 8.0]
                    3 >>> <span class="resaltado2">list</span>(<span class="resaltado2">zip</span>(asignaturas, notas))
                    4 [('Matemáticas', 6.0), ('Física', 3.5), ('Química', 7.5), ('Economía',
                    8.0)]
                    5 >>> <span class="resaltado2">dict</span>(<span class="resaltado2">zip</span>(asignaturas, notas[:3]))
                    6 {'Matemáticas': 6.0, 'Física': 3.5, 'Química': 7.5}
                </code>
                <h3>Operar todos los elementos de una colección iterable (reduce)</h3>
                <p>reduce(f, l) : Aplicar la función f a los dos primeros elementos de la secuencia l. Con el valor obtenido
                    vuelve a aplicar la función f a ese valor y el siguiente de la secuencia, y así hasta que no quedan más elementos
                    en la lista. Devuelve el valor resultado de la última aplicación de la función f.
                </p>
                <p>La función reduce está definida en el módulo functools.</p>
                <code>1 >>> <span class="resaltado">from</span> functools <span class="resaltado">import</span> <span class="resaltado2">reduce</span>
                    2 >>> <span class="resaltado">def</span> producto(n, m):
                    3 ... <span class="resaltado doble-ident">return</span> n * m
                    4 ...
                    5 >>> <span class="resaltado2">reduce</span>(producto, <span class="resaltado2">range</span>(1, 5))
                    6 24
                </code>
                <h2 id="Comprensión_de_colecciones">Comprensión de colecciones</h2>
                <p>En muchas aplicaciones es habitual aplicar una función o realizar una operación con los elementos de una colección
                    (lista, tupla o diccionario) y obtener una nueva colección de elementos transformados. Aunque esto se
                    puede hacer recorriendo la secuencia con un bucle iterativo, y en programación funcional mediante la función
                    map, Python incorpora un mecanismo muy potente que permite esto mismo de manera más simple.
                </p>
                <h3>Comprensión de listas</h3>
                <div class="borde-izq">
                    <p>[expresion <span class="resaltado">for</span> variable in lista <span class="resaltado">if</span> condicion]</p>
                </div>
                <p>Esta instrucción genera la lista cuyos elementos son el resultado de evaluar la expresión expresion, para cada
                    valor que toma la variable variable, donde variable toma todos los valores de la lista lista que cumplen la
                    condición condición.
                </p>
                <code>1 >>> [x ** 2 <span class="resaltado">for</span> x in <span class="resaltado2">range</span>(10)]
                    2 [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
                    3 >>> [x <span class="resaltado">for</span> x <span class="resaltado">in</span> <span class="resaltado2">range</span>(10) if x % 2 == 0]
                    4 [0, 2, 4, 6, 8]
                    5 >>> [x ** 2 <span class="resaltado">for</span> x in <span class="resaltado2">range</span>(10) if x % 2 == 0]
                    6 [0, 4, 16, 36, 64]
                    7 >>> notas = {'Carmen':5, 'Antonio':4, 'Juan':8, 'Mónica':9, 'María': 6,
                    'Pablo':3}
                    8 >>> [nombre <span class="resaltado">for</span> (nombre, nota) <span class="resaltado">in</span> notas.items() <span class="resaltado">if</span> nota >= 5]
                    9 ['Carmen', 'Juan', 'Mónica', 'María']
                </code>
                <h3>Comprensión de diccionarios</h3>
                <div class="borde-izq">
                    <p>{expresion‑clave:expresion‑valor <span class="resaltado">for</span> variables in lista <span class="resaltado">if</span> condicion}</p>
                </div>
                <p>Esta instrucción genera el diccionario formado por los pares cuyas claves son el resultado de evaluar la expresión
                    expresion‑clave y cuyos valores son el resultado de evaluar la expresión expresion‑valor, para cada valor
                    que toma la variable variable, donde variable toma todos los valores de la lista lista que cumplen la condición
                    condición.
                </p>
                <code>1 >>> {palabra:<span class="resaltado2">len</span>(palabra) <span class="resaltado">for</span> palabra <span class="resaltado">in</span> ['I', 'love', 'Python']}
                    2 {'I': 1, 'love': 4, 'Python': 6}
                    3 >>> notas = {'Carmen':5, 'Antonio':4, 'Juan':8, 'Mónica':9, 'María': 6,
                    'Pablo':3}
                    4 >>> {nombre: nota +1 <span class="resaltado">for</span> (nombre, nota) <span class="resaltado">in</span> notas.items() <span class="resaltado">if</span> nota >= 5])
                    5 {'Carmen': 6, 'Juan': 9, 'Mónica': 10, 'María': 7}
                </code>
            </article>
        </section>
        <section class="main-section" id="Ficheros">
            <header>Ficheros</header>
            <article>
                <p>
                    Hasta ahora hemos visto como interactuar con un programa a través del teclado (entrada de datos) y la terminal
                    (salida), pero en la mayor parte de las aplicaciones reales tendremos que leer y escribir datos en ficheros.
                    Al utilizar ficheros para guardar los datos estos perdurarán tras la ejecución del programa, pudiendo ser consultados
                    o utilizados más tarde.
                </p>
                <p>
                    Las operaciones más habituales con ficheros son:
                </p>
                <ul>
                    <li>
                        Crear un fichero.
                    </li>
                    <li>
                        Escribir datos en un fichero.
                    </li>
                    <li>
                        Leer datos de un fichero.
                    </li>
                    <li>
                        Borrar un fichero.
                    </li>
                </ul>
                <h3>Creación y escritura de ficheros</h3>
                <p>Para crear un fichero nuevo se utiliza la instrucción</p>
                <p>open(ruta, 'w') : Crea el fichero con la ruta ruta, lo abre en modo escritura (el argumento ‘w’ significa
                    write) y devuelve un objeto que lo referencia.
                </p>
                <p>Si el fichero indicado por la ruta ya existe en el sistema, se reemplazará por el nuevo.</p>
                <p>Una vez creado el fichero, para escribir datos en él se utiliza el método</p>
                <p>fichero.write(c) : Escribe la cadena c en el fichero referenciado por fichero.</p>
                <code>1 >>> f = <span class="resaltado2">open</span>('bienvenida.txt', 'w')
                    2 ... f.write('¡Bienvenido a Python!')
                </code>
                <h3>Añadir datos a un fichero</h3>
                <p>Si en lugar de crear un fichero nuevo queremos añadir datos a un fichero existente se debe utilizar la instrucción</p>
                <p>open(ruta, 'a') : Abre el fichero con la ruta ruta en modo añadir (el argumento ‘a’ significa append) y
                    devuelve un objeto que lo referencia.
                </p>
                <p>Una vez abierto el fichero, se utiliza el método de escritura anterior y los datos se añaden al final del fichero.</p>
                <code>1 >>> f = <span class="resaltado2">open</span>('bienvenida.txt', 'a')
                    2 ... f.write('\n¡Hasta pronto!')
                </code>
                <h3>Leer datos de un fichero</h3>
                <p>Para abrir un fichero en modo lectura se utiliza la instrucción</p>
                <p>open(ruta, 'r') : Abre el fichero con la ruta ruta en modo lectura (el argumento ‘r’ significa read) y devuelve
                    un objeto que lo referencia.
                </p>
                <p>Una vez abierto el fichero, se puede leer todo el contenido del fichero o se puede leer línea a línea.</p>
                <p>fichero.read() : Devuelve todos los datos contenidos en fichero como una cadena de caracteres.</p>
                <p>fichero.readlines() : Devuelve una lista de cadenas de caracteres donde cada cadena es una linea del
                    fichero referenciado por fichero.
                </p>
                <code>1 >>> f = <span class="resaltado2">open</span>('bienvenida.txt', 'r')
                    2 ... <span class="resaltado">print</span>(f.read())
                    3 ¡Bienvenido a Python!
                    4 ¡Hasta pronto!
                </code>
                <code>1 >>> f = <span class="resaltado2">open</span>('bienvenida.txt', 'r')
                    2 ... lineas = <span class="resaltado">print</span>(f.readlines())
                    3 >>> <span class="resaltado">print</span>(lineas)
                    4 ['Bienvenido a Python!\n', '¡Hasta pronto!']
                </code>
                <h3>Cerrar un fichero</h3>
                <p>Para cerrar un fichero se utiliza el método</p>
                <p>fichero.close() : Cierra el fichero referenciado por el objeto fichero.</p>
                <p>Cuando se termina de trabajar con un fichero conviene cerrarlo, sobre todo si se abre en modo escritura, ya
                    que mientras está abierto en este modo no se puede abrir por otra aplicación. Si no se cierra explícitamente un
                    fichero, Python intentará cerrarlo cuando estime que ya no se va a usar más.
                </p>
                <code>1 >>> f = <span class="resaltado2">open</span>('bienvenida.txt'):
                    2 ... <span class="resaltado">print</span>(f.read())
                    3 ... f.close() # Cierre del fichero
                    4 ...
                    5 ¡Bienvenido a Python!
                    6 ¡Hasta pronto!
                </code>
                <h3>Renombrado y borrado de un fichero</h3>
                <p>Para renombra o borrar un fichero se utilizan funciones del módulo os.</p>
                <p>os.rename(ruta1, ruta2) : Renombra y mueve el fichero de la ruta ruta1 a la ruta ruta2.</p>
                <p>os.remove(ruta) : Borra el fichero de la ruta ruta.</p>
                <p>Antes de borrar o renombra un directorio conviene comprobar que existe para que no se produzca un error. Para
                    ello se utiliza la función
                </p>
                <p>os.path.isfile(ruta) : Devuelve True si existe un fichero en la ruta ruta y False en caso contrario.</p>
                <h3>Renombrado y borrado de un fichero o directorio</h3>
                <code>1 >>> <span class="resaltado">import</span> os
                    2 >>> f = 'bienvenida.txt'
                    3 >>> <span class="resaltado">if</span> os.path.isfile(f):
                    4 ... <span class="doble-ident">os.rename(f, 'saludo.txt') # renombrado</span>
                    5 ... <span class="resaltado">else</span>:
                    6 ... <span class="resaltado doble-ident">print</span>('¡El fichero', f, 'no existe!')
                    7 ...
                    8 >>> f = 'saludo.txt'
                    9 >>> <span class="resaltado">if</span> os.path.isfile(f):
                    10 ... <span class="doble-ident">os.remove(f) # borrado</span>
                    11 ... <span class="resaltado">else</span>:
                    12 ... <span class="resaltado doble-ident">print</span>('¡El fichero', f, 'no existe!')
                    13 ...
                </code>
                <h3>Creación, cambio y eliminación de directorios</h3>
                <p>Para trabajar con directorios también se utilizan funciones del módulo os.</p>
                <p>os.listdir(ruta) : Devuelve una lista con los ficheros y directiorios contenidos en la ruta ruta.</p>
                <p>os.mkdir(ruta) : Crea un nuevo directorio en la ruta ruta.</p>
                <p>os.chdir(ruta) : Cambia el directorio actual al indicado por la ruta ruta.</p>
                <p>os.getcwd() : Devuelve una cadena con la ruta del directorio actual.</p>
                <p>os.rmdir(ruta) : Borra el directorio de la ruta ruta, siempre y cuando esté vacío.</p>
                <h3>Leer un fichero de internet</h3>
                <p>Para leer un fichero de internet hay que utilizar la función urlopen del módulo urllib.request.</p>
                <p>urlopen(url) : Abre el fichero con la url especificada y devuelve un objeto del tipo fichero al que se puede
                    acceder con los métodos de lectura de ficheros anteriores.
                </p>
                <code>1 >>> <span class="resaltado">from</span> urllib <span class="resaltado">import</span> request
                    2 >>> f = request.urlopen('https://raw.githubusercontent.com/asalber/
                    <span class="doble-ident">asalber.github.io/master/README.md')</span>
                    3 >>> datos = f.read()
                    4 >>> <span class="resaltado">print</span>(datos.decode('utf-8'))
                    5 Aprende con Alf
                    6 ===============
                    78
                    Este es el repositorio <span class="resaltado">del</span> sitio web Aprende con Alf: http://
                    aprendeconalf.es
                </code>
            </article>
        </section>
        <section class="main-section" id="Excepciones">
            <header>Excepciones</header>
            <article>
                <h2 id="Control_de_errores_mediante_excepciones">Control de errores mediante excepciones</h2>
                <p>
                    Python utiliza un objeto especial llamado <strong>excepción</strong> para controlar cualquier error que pueda ocurrir durante
                    la ejecución de un programa.
                </p>
                <p>
                    Cuando ocurre un error durante la ejecución de un programa, Python crea una excepción. Si no se controla esta
                    excepción la ejecución del programa se detiene y se muestra el error (traceback).
                </p>
                <code>1 >>> <span class="resaltado">print</span>(1 / 0) # Error al intentar dividir por 0.
                    2 Traceback (most recent call last):
                    3 File "&lt;stdin>", line 1, <span class="resaltado">in</span> &lt;module>
                    4 ZeroDivisionError: division by zero
                </code>
                <h3>Tipos de excepciones</h3>
                <p>Los principales excepciones definidas en Python son:</p>
                <ul>
                    <li>TypeError : Ocurre cuando se aplica una operación o función a un dato del tipo inapropiado.</li>
                    <li>ZeroDivisionError : Ocurre cuando se itenta dividir por cero.</li>
                    <li>OverflowError : Ocurre cuando un cálculo excede el límite para un tipo de dato numérico.</li>
                    <li>IndexError : Ocurre cuando se intenta acceder a una secuencia con un índice que no existe.</li>
                    <li>KeyError : Ocurre cuando se intenta acceder a un diccionario con una clave que no existe.</li>
                    <li>FileNotFoundError : Ocurre cuando se intenta acceder a un fichero que no existe en la ruta indicada.</li>
                    <li>ImportError : Ocurre cuando falla la importación de un módulo.</li>
                </ul>
                <p>Consultar la documentaciónde Python para ver la lista de exepciones predefinidas.</p>
                <h3>Control de excepciones</h3>
                <p> <strong>try - except - else</strong> Para evitar la interrución de la ejecución del programa cuando se produce un
                    error, es posible controlar la exepción que se genera con la siguiente instrucción:
                </p>
                <div class="borde-izq">
                    <p><span class="resaltado">try</span>:</p>
                    <p class="doble-ident"><em>bloque código 1</em></p>
                    <p>except <em>excepción</em>:</p>
                    <p class="doble-ident"><em>bloque código 2</em></p>
                    <p><span class="resaltado">else</span>:</p>
                    <p class="doble-ident"><em>bloque código 3</em></p>
                </div>
                <p>Esta instrucción ejecuta el primer bloque de código y si se produce un error que genera una excepción del tipo
                    excepción entonces ejecuta el segundo bloque de código, mientras que si no se produce ningún error, se ejecuta
                    el tercer bloque de código.
                </p>
                <code>1 >>> <span class="resaltado">def</span> division(a, b):
                    2 ... <span class="resaltado doble-ident">try</span>:
                    3 ... <span class="doble-ident"><span class="doble-ident">result = a / b</span></span>
                    4 ... <span class="resaltado doble-ident">except</span> ZeroDivisionError:
                    5 ... <span class="doble-ident"><span class="resaltado doble-ident">print</span>('¡No se puede dividir por cero!')</span>
                    6 ... <span class="resaltado doble-ident">else</span>:
                    7 ... <span class="doble-ident"><span class="resaltado doble-ident">print</span>(result)</span>
                    8 ...
                    9 >>> division(1, 0)
                    10 ¡No se puede dividir por cero!
                    11 >>> division(1, 2)
                    12 0.5
                </code>
                <code>1 >>> <span class="resaltado">try</span>:
                    2 ... <span class="doble-ident">f = <span class="resaltado2">open</span>('fichero.txt') # El fichero no existe</span>
                    3 ... <span class="resaltado">except</span> FileNotFoundError:
                    4 ... <span class="resaltado doble-ident">print</span>('¡El fichero no existe!')
                    5 ... <span class="resaltado">else</span>:
                    6 ... <span class="resaltado doble-ident">print</span>(f.read())
                    7 ¡El fichero no existe!
                </code>
            </article>
        </section>
        <section class="main-section" id="Apéndice:_Depuración_de_código">
            <header>Apéndice: Depuración de código</header>
            <article>
                <h2 id="Depuración_de_programas">Depuración de programas</h2>
                <p>
                    La depuración es una técnica que permite trazar un programa, es decir, seguir el flujo de ejecución de un programa
                    paso a paso, ejecutando una instrucción en cada paso, y observar el estado de sus variables.
                </p>
                <p>
                    Cuando un programa tiene cierta complejidad, la depuración es imprescindible pare detectar posibles errores.
                </p>
                <p>Python dispone del módulo pyd para depurar programas, pero es mucho más cómodo utilizar algún entorno
                    de desarrollo que incorpore la depuración, como por ejemplo Visual Studio Code.
                </p>
                <h3>Comandos de depuración</h3>
                <ul>
                    <li>Establecer punto de parada: Detiene la ejecución del programa en una línea concreta de código.</li>
                    <li>Continuar la ejecución: Continúa la ejecución del programa hasta el siguiente punto de parada o hasta
                        que finalice.</li>
                    <li>Próximo paso: Ejecuta la siguiente línea de código y para la ejecución.</li>
                    <li>Próximo paso con entrada en función: Ejecuta la siguiente línea de código. Si se trata de una llamada
                        a una función entonces ejecuta la primera instrucción de la función y para la ejecución.
                    </li>
                    <li>Próximo paso con salida de función: Ejecuta lo que queda de la función actual y para la ejecución.</li>
                    <li>Terminar la depuración: Termina la depuración.</li>
                </ul>
            </article>
        </section>
        <section class="main-section" id="Referencias">
            <header>Referencias</header>
            <article>
                <p>
                    Webs:
                </p>
                <ul>
                    <li>
                        <a href="https://www.python.org/">Python</a> Sitio web de Python.
                    </li>
                    <li>
                        <a href="http://repl.it/">Repl.it</a> Entorno de desarrollo web para varios lenguajes, incluido Python.
                    </li>
                    <li>
                        <a href="http://pythontutor.com/">Python tutor</a> Sitio web que permite visualizar la ejecución el código Python.
                    </li>
                </ul>
            </article>
        </section>
    </main>
</body>
</html>